"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ApiError: () => ApiError,
  Fetcher: () => Fetcher,
  arrayRequestBody: () => arrayRequestBody
});
module.exports = __toCommonJS(src_exports);

// src/types.ts
var never = Symbol();
var ApiError = class extends Error {
  headers;
  url;
  status;
  statusText;
  data;
  constructor(response) {
    super(response.statusText);
    Object.setPrototypeOf(this, new.target.prototype);
    this.headers = response.headers;
    this.url = response.url;
    this.status = response.status;
    this.statusText = response.statusText;
    this.data = response.data;
  }
};

// src/fetcher.ts
var sendBody = (method) => method === "post" || method === "put" || method === "patch" || method === "delete";
function queryString(params) {
  const qs = [];
  const encode = (key, value) => `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`;
  Object.keys(params).forEach((key) => {
    const value = params[key];
    if (value != null) {
      if (Array.isArray(value)) {
        value.forEach((value2) => qs.push(encode(key, value2)));
      } else {
        qs.push(encode(key, value));
      }
    }
  });
  if (qs.length > 0) {
    return `?${qs.join("&")}`;
  }
  return "";
}
function getPath(path, payload) {
  return path.replace(/\{([^}]+)\}/g, (_, key) => {
    const value = encodeURIComponent(payload[key]);
    delete payload[key];
    return value;
  });
}
function getQuery(method, payload, query) {
  let queryObj = {};
  if (sendBody(method)) {
    query.forEach((key) => {
      queryObj[key] = payload[key];
      delete payload[key];
    });
  } else {
    queryObj = { ...payload };
  }
  return queryString(queryObj);
}
function getHeaders(body, init) {
  const headers = new Headers(init);
  if (body !== void 0 && !headers.has("Content-Type")) {
    headers.append("Content-Type", "application/json");
  }
  if (!headers.has("Accept")) {
    headers.append("Accept", "application/json");
  }
  return headers;
}
function getBody(method, payload) {
  const body = sendBody(method) ? JSON.stringify(payload) : void 0;
  return method === "delete" && body === "{}" ? void 0 : body;
}
function mergeRequestInit(first, second) {
  const headers = new Headers(first?.headers);
  const other = new Headers(second?.headers);
  for (const key of other.keys()) {
    const value = other.get(key);
    if (value != null) {
      headers.set(key, value);
    }
  }
  return { ...first, ...second, headers };
}
function getFetchParams(request) {
  const payload = Object.assign(
    Array.isArray(request.payload) ? [] : {},
    request.payload
  );
  const path = getPath(request.path, payload);
  const query = getQuery(request.method, payload, request.queryParams);
  const body = getBody(request.method, payload);
  const headers = getHeaders(body, request.init?.headers);
  const url = request.baseUrl + path + query;
  const init = {
    ...request.init,
    method: request.method.toUpperCase(),
    headers,
    body
  };
  return { url, init };
}
async function getResponseData(response) {
  const contentType = response.headers.get("content-type");
  if (response.status === 204 || response.status === 304) {
    return void 0;
  }
  if (contentType && contentType.indexOf("application/json") !== -1) {
    return await response.json();
  }
  const text = await response.text();
  try {
    return JSON.parse(text);
  } catch (e) {
    return text;
  }
}
async function fetchJson(url, init) {
  const response = await fetch(url, init);
  const data = await getResponseData(response);
  const result = {
    headers: response.headers,
    url: response.url,
    ok: response.ok,
    status: response.status,
    statusText: response.statusText,
    data
  };
  if (result.ok) {
    return result;
  }
  throw new ApiError(result);
}
function wrapMiddlewares(middlewares, fetch2) {
  const handler = async (index, url, init) => {
    if (middlewares == null || index === middlewares.length) {
      return fetch2(url, init);
    }
    const current = middlewares[index];
    return await current(
      url,
      init,
      (nextUrl, nextInit) => handler(index + 1, nextUrl, nextInit)
    );
  };
  return (url, init) => handler(0, url, init);
}
async function fetchUrl(request) {
  const { url, init } = getFetchParams(request);
  const response = await request.fetch(url, init);
  return response;
}
function createFetch(fetch2) {
  const fun = async (payload, init) => {
    try {
      return await fetch2(payload, init);
    } catch (err) {
      if (err instanceof ApiError) {
        throw new fun.Error(err);
      }
      throw err;
    }
  };
  fun.Error = class extends ApiError {
    constructor(error) {
      super(error);
      Object.setPrototypeOf(this, new.target.prototype);
    }
    getActualType() {
      return {
        status: this.status,
        data: this.data
      };
    }
  };
  return fun;
}
function fetcher() {
  let baseUrl = "";
  let defaultInit = {};
  const middlewares = [];
  const fetch2 = wrapMiddlewares(middlewares, fetchJson);
  return {
    configure: (config) => {
      baseUrl = config.baseUrl || "";
      defaultInit = config.init || {};
      middlewares.splice(0);
      middlewares.push(...config.use || []);
    },
    use: (mw) => middlewares.push(mw),
    path: (path) => ({
      method: (method) => ({
        create: (queryParams) => createFetch(
          (payload, init) => fetchUrl({
            baseUrl: init?.baseUrl ?? (typeof baseUrl === "function" ? baseUrl() : baseUrl),
            path,
            method,
            queryParams: Object.keys(queryParams || {}),
            payload,
            init: mergeRequestInit(defaultInit, init),
            fetch: fetch2
          })
        )
      })
    })
  };
}
var Fetcher = {
  for: () => fetcher()
};

// src/utils.ts
function arrayRequestBody(array, params) {
  return Object.assign([...array], params);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ApiError,
  Fetcher,
  arrayRequestBody
});
